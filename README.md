# Алгоритми керування кешем

## Завдання 1. Оптимізація доступу до даних за допомогою LRU-кешу.

Реалізуйте програму для оптимізації обробки запитів до масиву чисел за допомогою LRU-кешу.

**Технічні умови**

1. Дано масив розміром N, який складається з позитивних цілих чисел (`1 ≤ N ≤ 100_000`). Потрібно обробити `Q` запитів (`1 ≤ Q ≤ 50_000`) такого типу:

- `Range(L, R)` — знайти суму елементів на відрізку від індексу `L` до `R` включно.
- `Update(index, value)` — замінити значення елемента в масиві за індексом `index` на нове значення `value`.

2. Реалізуйте чотири функції для роботи з масивом:

- `range_sum_no_cache(array, L, R)`

Функція має обчислювати суму елементів масиву на відрізку від `L` до `R` включно **без використання кешу**. Для кожного запиту результат має обчислюватися заново.

- `update_no_cache(array, index, value)`

Функція має оновлювати значення елемента масиву за вказаним індексом **без використання кешу**.

- `range_sum_with_cache(array, L, R)`

Функція має обчислювати суму елементів на відрізку від `L` до `R` включно, використовуючи **LRU-кеш**.
Якщо сума для цього відрізку вже була обчислена раніше, вона має повертатися з кешу, інакше результат обчислюється та додається в кеш.

- `update_with_cache(array, index, value)`

Функція має оновлювати значення елемента масиву за вказаним індексом і **видаляти всі відповідні значення з кешу**, які стали неактуальними через зміну в масиві.

3. Для тестування програми створіть масив розміром `100_000` елементів, заповнених випадковими числами, і згенеруйте `50_000` запитів типу `Range` та `Update` у випадковому порядку.

Приклад списку запитів: `[('Range', 46943, 91428), ('Range', 5528, 29889), ('Update', 77043, 78), ...]`

4. Використовуйте LRU-кеш розміром `K = 1000` для зберігання попередньо обчислених результатів запитів типу `Range`.
   Кеш повинен автоматично видаляти найменш недавно використані елементи, якщо досягається його максимальний розмір.

5. Здійсніть порівняння часу виконання запитів:

- Без використання кешу.
- З використанням LRU-кешу.
- Виведіть результати у вигляді часу виконання для обох підходів.

## Завдання 2. Порівняння продуктивності обчислення чисел Фібоначчі із використанням LRU-кешу та Splay Tree.

Реалізуйте програму для обчислення чисел Фібоначчі двома способами: із використанням LRU-кешу та з використанням Splay Tree для збереження попередньо обчислених значень.
Проведіть порівняльний аналіз їхньої ефективності, вимірявши середній час виконання для кожного з підходів.

**Технічні умови**

1. Реалізуйте дві функції для обчислення чисел Фібоначчі:

- `fibonacci_lru(n)`

Функція має використовувати декоратор `@lru_cache` для кешування результатів обчислень.
Завдяки цьому вона може повторно використовувати попередньо обчислені значення чисел Фібоначчі.

- `fibonacci_splay(n, tree)`

Функція використовує структуру даних Splay Tree для збереження обчислених значень.
Якщо число Фібоначчі для заданого `n` уже було обчислене, значення має повертатися з дерева, інакше значення обчислюється, зберігається у Splay Tree і повертається.

2. Виміряйте час виконання обчислення чисел Фібоначчі для кожного з підходів:

- Створіть набір чисел Фібоначчі від `0` до `950` з кроком `50`: `0, 50, 100, 150, ....`
- Використовуйте модуль `timeit` для вимірювання часу виконання обчислень.
- Для кожного значення `n` обчисліть середній час виконання обчислення числа Фібоначчі з використанням `LRU-кешу` та `Splay Tree`.

3. Побудуйте графік, який порівнює час виконання для двох підходів:

- Використовуйте бібліотеку `matplotlib` для побудови графіка.
- На осі `x` відобразіть значення `n` — номер числа Фібоначчі.
- На осі `y` — середній час виконання в секундах.
- Додайте на графік легенду, яка вказує на два підходи: `LRU Cache` та `Splay Tree`.

4. Зробіть висновки щодо ефективності обох підходів на основі отриманого графіка.

5. Додатково до побудови графіка виведіть текстову таблицю, яка містить значення `n`, середній час виконання для `LRU Cache` та `Splay Tree`.
   Таблиця повинна бути відформатована для зручного читання.

**Результати**

| n   | LRU Cache Time (s) | Splay Tree Time (s) |
| --- | ------------------ | ------------------- |
| 0   | 0.0000002900       | 0.0000007000        |
| 50  | 0.0000014500       | 0.0000052800        |
| 100 | 0.0000013300       | 0.0000081200        |
| 150 | 0.0000012200       | 0.0000160800        |
| 200 | 0.0000013600       | 0.0000186800        |
| 250 | 0.0000012200       | 0.0000259600        |
| 300 | 0.0000013700       | 0.0000301000        |
| 350 | 0.0000015100       | 0.0000351600        |
| 400 | 0.0000013200       | 0.0000430200        |
| 450 | 0.0000016100       | 0.0000476800        |
| 500 | 0.0000015000       | 0.0000522200        |
| 550 | 0.0000013800       | 0.0000539900        |
| 600 | 0.0000014500       | 0.0000639300        |
| 650 | 0.0000015800       | 0.0000671500        |
| 700 | 0.0000028400       | 0.0000759300        |
| 750 | 0.0000014100       | 0.0000772000        |
| 800 | 0.0000013800       | 0.0000873900        |
| 850 | 0.0000016100       | 0.0000896500        |
| 900 | 0.0000013700       | 0.0000953400        |
| 950 | 0.0000014200       | 0.0000979500        |

**Графік**

На графіку видно чітку різницю між часом виконання методів. Метод LRU-кешування демонструє значно кращу продуктивність у порівнянні зі Splay Tree.

![](/img/diagram.jpg)

**Висновки**

**LRU-кешування:**

- Використання мемоізації `(functools.lru_cache)` забезпечує найкращу продуктивність для Fibonacci.
- Час виконання майже незмінний при зростанні `n`.
- Ідеально підходить для чистих функцій, де немає потреби у динамічному оновленні кешу.

**Splay Tree:**

- Має вищу вартість доступу, оскільки при кожному запиті виконується сплаювання (реорганізація дерева).
- Не підходить для Fibonacci, але корисний для структур із динамічним доступом до даних, наприклад, кешу сторінок або баз даних.

**Рекомендація:**

- Для обчислення Fibonacci слід використовувати LRU-кешування.
- Splay Tree корисний для сценаріїв, коли потрібно часто оновлювати або змінювати кешовані значення, а не просто зберігати їх.
